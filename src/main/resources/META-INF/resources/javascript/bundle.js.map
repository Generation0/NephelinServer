{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/javascript/entry.js","src/javascript/nephelin/Board.js","src/javascript/nephelin/CanvasHelper.js","src/javascript/nephelin/ClientSessionController.js","src/javascript/nephelin/Hexagon.js","src/javascript/nephelin/HexagonAlgebra.js","src/javascript/nephelin/MapGenerators.js","src/javascript/nephelin/Messages.js","src/javascript/nephelin/SidePanel.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n/**\n * Created by sirmonkey on 4/11/15.\n */\nvar ClientSessionController = require('./nephelin/ClientSessionController');\nvar SidePanel = require('./nephelin/SidePanel');\n\n$( document ).ready(function() {\n    console.log('ClientSessionController starting!');\n    var csc = new ClientSessionController.csc('/NephelinServer');\n    ClientSessionController.addReceiver(SidePanel.sp);\n    csc.openConnection();\n    csc.buildComponents();\n    console.log('ClientSessionController started!');\n});\n","'use strict';\n/**\n * @param columnSize\n * @param hexagonSideSize\n * @param mapType\n * @constructor\n */\nvar Hexagon = require('./Hexagon');\nvar mapgen = require('./MapGenerators');\nvar HexagonAlgebra = require('./HexagonAlgebra');\nvar CanvasHelper = require('./CanvasHelper');\n//TODO: getCanvas from SidePanel\nvar Board;\nBoard =  function Board(columnSize, hexagonSideSize, mapType) {\n    var self = this;\n    this.reference_point = new HexagonAlgebra.Axial(350,400);\n    this.hexagonSideSize = hexagonSideSize;\n    this.columnSize = columnSize;\n    this.mapType = mapType;\n    this.hexagonQueue = {};\n    switch (mapType) {\n        case 'oddRowMap':\n            this.map = mapgen.oddRowMap(columnSize, hexagonSideSize);\n            break;\n        default :\n            this.map = mapgen.normalMap(columnSize, hexagonSideSize);\n            break;\n    }\n    this.actions = {\n        selectHexagon: function selectHexagon(hexagon) {\n            if(typeof self.hexagonQueue[hexagon.coordinate] === 'undefined'){\n                hexagon.bgImg.src = 'images/selected.png';\n                self.hexagonQueue[hexagon.coordinate] = hexagon;\n            }\n            else{\n                hexagon.bgImg.src = 'images/normal.png';\n                delete self.hexagonQueue[hexagon.coordinate];\n            }\n        }\n    };\n    this.handlers = {\n        click: function clickHandler(e) {\n            //Todo refactor to be independent of click event\n            console.log('click_offset: ' + e.offsetX + '/' + e.offsetY);\n            var click_point = new HexagonAlgebra.Axial(e.offsetX, e.offsetY);\n            var coordinate = HexagonAlgebra.pixel_to_hex(self.reference_point, click_point, self.hexagonSideSize);\n            var hex = self.map[coordinate];\n            var canvas =CanvasHelper.getCanvas()\n            var ctx = canvas.getContext('2d');\n            if (typeof hex !== 'undefined') {\n                console.log(\"It's a hit!\");\n                self.actions.selectHexagon(hex);\n                Hexagon.drawHexagon(ctx,hex);\n                console.log(self.map[coordinate]);\n            } else {\n                console.log(\"No hit!\");\n            }\n            if (typeof Object.keys(self.hexagonQueue) !== 'undefined') {\n                drawMap(canvas, self.hexagonQueue, self.reference_point);\n            }\n        },\n        scroll: function scrollHandler(canvas, movement_vector) {\n            self.reference_point.q += movement_vector.q;\n            self.reference_point.r += movement_vector.r;\n            canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);\n            drawMap(canvas, self.map, self.reference_point);\n            drawMap(canvas, self.hexagonQueue, self.reference_point);\n        }\n    };\n};\nmodule.exports = Board;\n\nfunction drawHexagonGrid(ctx, map, reference_point) {\n    for(var coordinate_hexagon in map) {\n        if (map.hasOwnProperty(coordinate_hexagon)) {\n            // prop is not inherited\n            var hex = map[coordinate_hexagon];\n            hex.calcAltPoints(reference_point);\n            Hexagon.drawHexagon(ctx, hex);\n        }\n    }\n}\n\n/**\n *  *\n * @param {CanvasRenderingContext2D} canvas - html canvas\n * @param hex\n */\nfunction drawMap(canvas, map, reference_point) {\n    var ctx = canvas.getContext('2d');\n    reference_point = reference_point || new HexagonAlgebra.Axial(350,400);\n    drawHexagonGrid(ctx, map, reference_point);\n    // drawForeground(ctx);\n}\nmodule.exports.drawMap = drawMap;\n\n\n\n\n// Test key movement (catch arrow key events)\n//turnKeys = function() {\n//    //TODO Something useful\n//    $(document).keydown(function(e) {\n//        switch(e.which) {\n//            case 37: // left\n//                console.log(\"left\");\n//                break;\n//\n//            case 38: // up\n//                console.log(\"up\");\n//                break;\n//\n//            case 39: // right\n//                console.log(\"right\");\n//                break;\n//            case 40: // down\n//                console.log(\"down\");\n//                break;\n//\n//            default: return; // exit this handler for other keys\n//        }\n//        e.preventDefault(); // prevent the default action (scroll / move caret)\n//    });\n//};\n","/**\n * Created by sirmonkey on 4/18/15.\n */\n\nfunction getCanvas() {\n    if ($(\"#cv\").length) {\n        return $(\"#cv\").get(0);\n    } else {\n        console.log('Error: Canvas not found with selector #cv');\n    }\n}\nmodule.exports.getCanvas = getCanvas;","'use strict';\n/**\n * Created by sirmonkey on 4/2/15.\n */\n/**\n * Initialize Hub and websocket connection.\n * @constructor\n * @param {string} contextpath - Path for the websocket connection.\n */\n\nvar Messages = require('./Messages');\nvar receivers    = [],\n    components   = {};\nvar ClientSessionController;\nClientSessionController     = function ClientSessionController(contextpath) {\n    var self = this;\n    var hostname = window.location.hostname;\n    this.connection = \"ws://\" + hostname + \":8080\" + contextpath + \"/messagechannel\";\n    this.socket = null;\n    this.commands = {\n        log: function log(msg) {\n            console.log(msg);\n        },\n        response: function response(msg){\n            console.log(msg);\n        },\n        wait: function wait(msg) {\n            console.log(Date.now() + \" CMD: Waiting\");\n            self.send(Messages.newGame);\n        },\n        relay: function relay(msg) {\n            console.log('Begin Relay');\n            console.log(msg);\n            var receiver = msg.receiver;\n            console.log('Relay to: ' + receiver);\n            var cmp = components[receiver];\n            if (typeof cmp !== 'undefined') {\n                cmp.receive(msg);\n            } else {\n                console.log('Receiver: ' + receiver + ' not found!');\n            }\n            console.log('End Relay');\n        }\n    };\n};\n\n\nClientSessionController.prototype  = {\n    send : function (msg) {\n    this.socket.send(JSON.stringify(msg));\n    },\n    receive: function receive(event) {\n        console.log(event);\n        var msg        = JSON.parse(event.data);\n        var command = this.commands[msg.command];\n        if (command !== undefined) {\n            if(msg.ack === 'true') {\n                this.acknowledge(msg);\n            }\n            command(msg);\n        } else {\n          console.log(\"Error: Command not found!\") ;\n        }\n    },\n    acknowledge: function acknowledge(msg) {\n        this.send(Messages.ack(msg.receiver, msg.sender, msg.command));\n    },\n    openConnection: function openConnection() {\n        if (this.socket === null) {\n            this.socket = new WebSocket(this.connection);\n            this.socket.onmessage = this.receive.bind(this);\n        }\n    },\n    buildComponents: function buildComponents() {\n        console.log(\"Components found: \" + receivers.length);\n        for (var index = 0; index < receivers.length; index+=1) {\n            var CmpBuilder = receivers[index];\n            var cmp        = new CmpBuilder(this.send, this.socket);\n            components[cmp.name] = cmp;\n        }\n        console.log(\"Components build: \" + components.length);\n        console.log(\"----------\");\n    }\n};\nmodule.exports.csc                     = ClientSessionController;\nmodule.exports.addReceiver             = function (receiver) {\n    receivers.push(receiver);\n};\n\n\nmodule.exports.receivers = function () {\n    return receivers;\n};","'use strict';\n/**\n * Created by sirmonkey on 4/2/15.\n */\n\n\nvar HexagonAlgebra = require('./HexagonAlgebra');\n/*\n * ##############################################################################################\n * #\t\t\t\t\t\t\t\t\t\tHexagon\t\t\t\t\t\t\t\t\t\t\t\t#\n * ##############################################################################################\n */\n\n/**\n *\n * @constructor\n * @param {Cube} coordinate triplet (x , y, z)\n * @param {number} hexagonSideSize - Side length from the hexagon.\n */\nvar Hexagon;\nHexagon = function Hexagon(coordinate, hexagonSideSize) {\n    this.coordinate = coordinate;\n    this.size = hexagonSideSize;\n    this.center     = null;\n    this.corners    = null;\n    this.calcAltPoints(new HexagonAlgebra.Axial(0,0));\n\n    this.bgImg = new Image();\n    this.bgImg.src = \"images/normal.png\";\n    this.foregroundImg = null;\n    this.bordersColor = ['black','black','black','black','black','black'];\n    this.selected = false;\n};\nmodule.exports = Hexagon;\n\nHexagon.prototype = {\n    calcPoints: function calcPoints(reference_point) {\n        this.center     = HexagonAlgebra.hex_center(reference_point, this.coordinate, this.size);\n        this.corners    = HexagonAlgebra.hex_corners(this.center, this.size);\n    },\n    calcAltPoints: function calcAltPoints(reference_point) {\n        this.center     = HexagonAlgebra.cubetopixel(reference_point, this.coordinate, this.size);\n        this.corners    = HexagonAlgebra.hex_corners(this.center, this.size);\n    }\n};\n\n/**\n * Creates the hexagon path for drawing.\n *\n * @param {CanvasRenderingContext2D} ctx - Canvas 2d context.\n * @param first\n * @param second\n * @param begin\n * @param close\n */\nfunction setHexagonSide(ctx , first, second, begin , close ) {\n    //TODO: Refactor\n    begin = typeof begin !== 'undefined' ?  begin : true;\n    close = typeof close !== 'undefined' ?  close : true;\n    if (begin) {\n        ctx.beginPath();\n        ctx.moveTo(first.q, first.r);\n    }\n    ctx.lineTo(second.q, second.r);\n    if (close) {ctx.closePath();}\n}\n\n\nfunction drawHexagonSide(ctx , first, second, color) {\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = color;\n    setHexagonSide(ctx,first,second);\n    ctx.stroke();\n}\n\n/**\n * Draws the Hexagon's border.\n *\n * @param {CanvasRenderingContext2D} ctx - Canvas 2d context.\n * @param hex\n */\nfunction drawHexagonSides(ctx, hex) {\n    //TODO: Refactor\n    ctx.save();\n    for (var i = 0; i < hex.bordersColor.length; i+=1) {\n        var second = hex.corners[(i+1) % hex.bordersColor.length];\n        drawHexagonSide(ctx,hex.corners[i],second, hex.bordersColor[i]);\n    }\n    ctx.restore();\n}\nmodule.exports.drawHexagonSides = drawHexagonSides;\n\n/**\n * Something about clipping\n * @param ctx\n * @param hex\n */\nfunction setHexagonSides(ctx, hex) {\n    //TODO: Refactor -- Magic & Unicorns\n    setHexagonSide(ctx, hex.corners[0], hex.corners[1], true, false);\n    setHexagonSide(ctx, hex.corners[1], hex.corners[2], false, false);\n    setHexagonSide(ctx, hex.corners[2], hex.corners[3], false, false);\n    setHexagonSide(ctx, hex.corners[3], hex.corners[4], false, false);\n    setHexagonSide(ctx, hex.corners[4], hex.corners[5], false, false);\n    setHexagonSide(ctx, hex.corners[5], hex.corners[0], false, true);\n\n}\n\n/**\n * Draws the Hexagon Background.\n *\n * @param {CanvasRenderingContext2D} ctx - Canvas 2d context.\n * @param {Hexagon} hex\n */\nfunction drawHexagonBackground(ctx, hex) {\n    if (hex.bgImg !== null) {\n        ctx.save();\n        setHexagonSides(ctx, hex);\n        ctx.clip();\n        ctx.drawImage(hex.bgImg, 0, 0, hex.bgImg.width, hex.bgImg.height, hex.corners[5].q, hex.corners[0].r, hex.corners[2].q - hex.corners[5].q, hex.corners[3].r - hex.corners[0].r);\n        ctx.restore();\n    }\n}\n\n/**\n * Draws the Hexagon Background.\n * @param {CanvasRenderingContext2D} ctx\n * @param {Hexagon} hex\n */\nfunction drawForeground(ctx, hex) {\n    ctx.save();\n    ctx.font=\"12px Consolas\";\n\n    var tmp = hex.coordinate.toOffset_OddR();\n    ctx.fillStyle = 'Blue';\n    ctx.fillText(hex.coordinate.z, hex.corners[0].q - 6, hex.corners[0].r - 12.5);\n    ctx.fillStyle = 'DarkSalmon';\n    ctx.fillText(hex.coordinate.y, hex.corners[2].q + 7.5, hex.corners[2].r + 7.5);\n    ctx.fillStyle = 'LightGreen';\n    ctx.fillText(hex.coordinate.x, hex.corners[4].q - 12, hex.corners[2].r + 7.5);\n    ctx.fillStyle = 'white';\n    ctx.fillText(tmp.r+\"/\"+tmp.q+\"\", hex.center.q - 6, hex.center.r + 6);\n    //\"/\"+hex.coordinate.z+\"/\"+hex.coordinate.x, hex.center.q - 15, hex.center.r + 7.5);\n    ctx.restore();\n}\n\n/**\n * Draws a 'Grid' on the Hexagons\n * @param ctx\n * @param hex\n */\nfunction drawTestGrid(ctx, hex) {\n    ctx.save();\n    var color = 'white';\n    drawHexagonSide(ctx,hex.corners[0], hex.corners[3], color);\n    drawHexagonSide(ctx,hex.corners[1], hex.corners[5], color);\n    drawHexagonSide(ctx,hex.corners[2], hex.corners[4], color);\n    ctx.restore();\n}\n\n/**\n * Draws the Hexagon into the given context.\n *\n * @param {CanvasRenderingContext2D} ctx - Canvas 2d context.\n * @param hex\n */\nmodule.exports.drawHexagon = function drawHexagon(ctx, hex) {\n    drawHexagonBackground(ctx, hex);\n    drawHexagonSides(ctx, hex);\n    //drawTestGrid(ctx, hex);\n    drawForeground(ctx, hex);\n};","'use strict';\n/**\n * Created by sirmonkey on 4/13/15.\n */\n\n/**\n * Maybe useful??\n * @param first\n * @param second\n * @returns {number}\n */\n\nvar scalarCrossProduct;\nscalarCrossProduct = function (first, second) {\n    return (first.q - second.q ) * (first.r - second.r);\n};\n\n/**\n * Axial Coordinate Point on cavas\n *\n * @constructor\n * @param q Column (x-axis on convas)\n * @param r Row (y-axis on canvas)\n */\nvar Axial;\nAxial = function Axial(q, r){\n    this.q = q;\n    this.r = r;\n};\nmodule.exports.Axial = Axial;\n\n\n/**\n * Cube Coordinate aka 3D.\n *\n * @constructor\n * @param x\n * @param y\n * @param z\n */\nvar Cube;\nCube = function Cube(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n};\nmodule.exports.Cube = Cube;\n\nAxial.prototype.toCubefromOffset_OddR = function() {\n    var x = this.q - (this.r - (this.r % 2)) / 2;\n    var z = this.r;\n    var y = -x-z;\n    return new Cube(x,y,z);\n};\n\nAxial.prototype.toCube = function() {\n    var x = this.q;\n    var y = this.r;\n    var z = -x-y;\n    return new Cube(x, y, z);\n};\n\n\n\nCube.prototype.toString = function() {\n    return \"x:\" + this.x.toString() + \"y:\" +\n        this.y.toString() + \"z:\" + this.z.toString();\n};\n/**\n * Converts cube coordinate into axial coordinate.\n * @returns {Axial}\n */\nCube.prototype.toAxial = function() {\n    return new Axial(this.x, this.y);\n};\n\n/**\n * Converts cube coordinates to \"easy\" canvas coordinates.\n * @returns {Axial}\n */\nCube.prototype.toOffset_OddR = function () {\n    var q = this.x + (this.z - (this.z % 2)) / 2;\n    var r = this.z;\n    return new Axial(q, r);\n};\n\n/**\n * Rounds a floating point cube into the nearest integer cube.\n * @param cube\n * @returns {Cube}\n */\nvar cube_round = function cube_round(cube) {\n    var rx = Math.round(cube.x);\n    var ry = Math.round(cube.y);\n    var rz = Math.round(cube.z);\n\n    var x_diff = Math.abs(rx - cube.x);\n    var y_diff = Math.abs(ry - cube.y);\n    var z_diff = Math.abs(rz - cube.z);\n\n    if (x_diff > y_diff && x_diff > z_diff) {\n        rx = -ry-rz;\n    }else if (y_diff > z_diff) {\n        ry = -rx-rz;\n    }\n    else {\n        rz = -rx-ry;\n    }\n\n\n    return new Cube(rx, ry, rz);\n};\nmodule.exports.cube_round = cube_round;\n\n/**\n * Calculates the center of a Hexagon in canvas representation for a Odd Row Map\n *\n * @constructor\n * @param {Cube} coordinate\n * @param {Number} size of the Hexagon.\n * @returns {Axial}\n * @deprecated\n */\nvar hex_center = function hex_center(reference_point, coordinate, size) {\n    //Todo Remove Magic and Unicorns\n    var hex = coordinate.toOffset_OddR();\n    var height = size  * 2;\n    var width = Math.sqrt(3)/ 2 * height ;\n    var x = (width / 2) + width*hex.q;\n    var y = size + 3/4 * height * hex.r;\n    if(hex.r === 0) {\n        x = (width / 2) + width*hex.q;\n        y = size;\n    } else if(hex.r % 2 === 1){\n        x = hex.q === 0 ? width:width+width*hex.q;\n    }\n    return new Axial(x + reference_point.q, y + reference_point.r);\n};\nmodule.exports.hex_center = hex_center;\n\nfunction cubeToPixel(reference_point, coordinate, size) {\n    var axial = coordinate.toAxial(),\n        x, y;\n    x =reference_point.q + size * Math.sqrt(3) * (axial.q + axial.r/2);\n    y =reference_point.r + size * 3/2 * axial.r;\n    return new Axial(x, y);\n}\nmodule.exports.cubetopixel = cubeToPixel;\n\n//TODO: Better ASCII ART\n/**\n *    0____1\n *   /      \\\n * 5/   C    \\2\n *  \\       /\n *  4\\ ___ /3\n * @param center\n * @param size\n * @param i\n * @param topped Orientation (pointy or flat)\n * @returns {Axial}\n */\nvar hex_corner  = function hex_corner(center, size, i, topped) {\n    topped = typeof topped !== 'undefined' ?  topped : 'flat';\n    var adjust = topped !== 'pointy' ? 0 : 90;\n    var angle_deg = 60 * i + adjust;\n    var angle_rad = Math.PI / 180 * angle_deg;\n    return new Axial(center.q + size * Math.cos(angle_rad),\n        center.r + size * Math.sin(angle_rad));\n};\nmodule.exports.hex_corner = hex_corner;\n/**\n *\n * @param center\n * @param size\n * @returns {Array} Containing the Corners\n */\nvar hex_corners = function hex_corners(center, size) {\n    var corners = [];\n    for(var i = 0; i < 6; i=i+1) {\n        corners.push(hex_corner(center,size, i, 'pointy'));\n    }\n    return corners;\n};\nmodule.exports.hex_corners = hex_corners;\n\nfunction hex_neighbors(coordinate) {\n    return [new Cube(coordinate.x+1, coordinate.y-1, coordinate.z),\n        new Cube(coordinate.x+1, coordinate.y, coordinate.z-1),\n        new Cube(coordinate.x, coordinate.y+1, coordinate.z-1),\n        new Cube(coordinate.x-1, coordinate.y+1, coordinate.z),\n        new Cube(coordinate.x-1, coordinate.y, coordinate.z+1),\n        new Cube(coordinate.x, coordinate.y-1, coordinate.z+1)];\n}\nmodule.exports.hex_neighbors = hex_neighbors;\n\n\n/**\n * Checks if the given point is inside the polygon.\n * Uses Cross Product (2D)\n * @param {Axial} point to check.\n * @param {Array} vertices\n * @returns {boolean} true if the point is inside and false if not.\n */\nvar isPointIn = function isPointIn (point, vertices) {\n    //Todo Algorithm that detects sides.\n    var i, j;\n    var found = true;\n    for (i = 0, j = vertices.length - 1; i < vertices.length && found; i+=1) {\n        var xProduct = (vertices[j].q - vertices[i].q) *\n            (point.r - vertices[i].r) - (vertices[j].r - vertices[i].r) *\n            (point.q - vertices[i].q);\n        if (0 < xProduct && found) {\n            found = false;\n        }\n        j = i;\n    }\n    return found;\n};\nmodule.exports.isPointIn = isPointIn;\nmodule.exports.pixelToCube = function pixelToCube(ref_point, point, size){\n    //Todo Remove Magic and Unicorns\n    // Magic and Unicorns -- Start\n    var height = size  * 2;\n    var width = Math.sqrt(3)/ 2 * height ;\n    console.log(ref_point);\n    var a = point.q - ref_point.q;\n    var b = point.r - ref_point.r;\n    var q = a/width -1/2;\n    var r = (4 * (b - size) ) / (3 * height );\n    // Magic and Unicorns -- End\n    var floatingPointCube = (new Axial(q,r)).toCubefromOffset_OddR();\n    var first_candidate_coord = cube_round(floatingPointCube);\n    var neighbors = hex_neighbors(first_candidate_coord);\n    var candidates = [first_candidate_coord].concat(neighbors);\n    var result = null;\n    for (var i = 0; i<candidates.length; i= i+1) {\n        var center = hex_center(ref_point, candidates[i], size);\n        if (isPointIn(point, hex_corners(center, size))) {\n            console.log(\"Coordinate converted\");\n            console.log('Candidate Nr: ' + i);\n            console.log((candidates[i]));\n            result = candidates[i];\n            break;\n        }\n    }\n    return result;\n};\nfunction pixel_to_hex(ref_point, point, size){\n    //Todo Remove Magic and Unicorns\n    // Magic and Unicorns -- Start\n    var y =  point.r - (ref_point.r);\n    var x =  point.q - ( ref_point.q);\n    var r = y / ( size * 3/2 );\n    var q = x /(size * Math.sqrt(3) ) - r/2;\n    var ax = (new Axial(q,r));\n    var floatingPointCube = ax.toCube();\n    var first_candidate_coord = cube_round(floatingPointCube);\n    console.log(first_candidate_coord);\n    var neighbors = hex_neighbors(first_candidate_coord);\n    var candidates = [first_candidate_coord].concat(neighbors);\n    var result = null;\n    for (var i = 0; i<candidates.length; i= i+1) {\n        var center = cubeToPixel(ref_point, candidates[i], size);\n        if (isPointIn(point, hex_corners(center, size))) {\n            console.log(\"Coordinate converted\");\n            console.log('Candidate Nr: ' + i);\n            console.log((candidates[i]));\n            result = candidates[i];\n            break;\n        }\n    }\n    return result;\n}\nmodule.exports.pixel_to_hex = pixel_to_hex;\n\n","'use strict';\n/**\n * Created by sirmonkey on 4/13/15.\n */\nvar Hexagon = require('./Hexagon');\nvar HexagonAlgebra = require('./HexagonAlgebra');\nmodule.exports.oddRowMap =  function oddRowMap(columnSize, hexagonSideSize) {\n    var map = {};\n    var track = 0;\n    var hex_count = 0;\n    for (var z = 0; z < columnSize; z+=1) {\n        var res = z % 2;\n        var x_count = columnSize - (res);\n        var x = 0;\n        if (res === 0 && z > 0) {\n            track= track + 1;\n            x = x - track;\n            x_count = x_count - track;\n        }\n        if (res === 1) {\n            x = 0 - track;\n            x_count = x_count - track;\n        }\n        for (;x < x_count; x+=1) {\n            var y  = -x-z;\n            var coordinates = new HexagonAlgebra.Cube(x, y, z);\n            var stopRandom = false;\n            if (Math.floor(Math.random() * 2) === 0 || stopRandom) {\n                var hexagon = new Hexagon(coordinates, hexagonSideSize);\n                hex_count= hex_count + 1;\n                map[coordinates]= hexagon;\n            }\n        }\n    }\n    console.log(\"Hex Count: \" + hex_count);\n    return map;\n};\nmodule.exports.normalMap =  function normalMap(columnSize, hexagonSideSize) {\n    var map = {};\n    var track = 0;\n    var hex_count = 0;\n    for (var z = 0; z < columnSize; z+=1) {\n        var res = z % 2;\n        var x_count = columnSize - (res);\n        var x = 0;\n        if (res === 0 && z > 0) {\n            track= track + 1;\n            x = x - track;\n            x_count = x_count - track;\n        }\n        if (res === 1) {\n            x = 0 - track;\n            x_count = x_count - track;\n        }\n        for (;x < x_count; x+=1) {\n            var y  = -x-z;\n            var coordinates = new HexagonAlgebra.Cube(x, y, z);\n            var stopRandom = true;\n            if (Math.floor(Math.random() * 2) === 0 || stopRandom) {\n                var hexagon = new Hexagon(coordinates, hexagonSideSize);\n                hexagon.calcAltPoints(new HexagonAlgebra.Axial(0,0));\n                hex_count += 1;\n                map[coordinates]= hexagon;\n            }\n        }\n    }\n    console.log(\"Hex Count: \" + hex_count);\n    return map;\n};","'use strict';\n/**\n * Created by sirmonkey on 4/13/15.\n */\nmodule.exports.ping = {\n    command: 'log',\n    receiver: 'SidePanelController',\n    action: 'ping'\n};\n\nmodule.exports.ack = function(sender, receiver, payload) {\n    var msg;\n    msg = {\n        command: 'response',\n        receiver: receiver,\n        sender: sender,\n        payload: payload,\n        ack: false\n    };\n    return msg;\n};\nmodule.exports.newGame = {\n    command: \"relay\",\n    receiver: \"GameController\",\n    action: \"newGame\"\n};","'use strict';\n/**\n * Created by sirmonkey on 4/3/15.\n */\nvar Board = require('./Board');\nvar Messages = require('./Messages');\nvar HexagonAlgebra = require('./HexagonAlgebra');\nvar CanvasHelper = require('./CanvasHelper');\n\nfunction isClick(board, mousedown, mouseup) {\n    if (mousedown.offsetX === mouseup.offsetX &&\n        mousedown.offsetY === mouseup.offsetY) {\n        board.handlers.click(mousedown);\n    }\n}\n\nvar SidePanel;\nSidePanel = function SidePanel(sendMessageFunc, socket) {\n    console.log(Date.now() + ' Sidepanel started.');\n    var self = this;\n    this.send = sendMessageFunc;\n    this.socket      = socket;\n    this.name      = \"sidepanel\"; // TODO: Besseren namen!\n    this.actions = {\n        joinGame: function (msg) {\n            var response  = {\n                \"command\": \"relay\", \"receiver\": \"GameController\",\n                \"action\": \"joinGame\",\n                \"payload\": msg.payload\n            };\n\n            var disp      = JSON.stringify(msg.payload);\n            $('#SidePanel').append('<p>' + disp + '<p>');\n            var canvas    = CanvasHelper.getCanvas();\n            var board     = new Board(7, 40, 'normalMap');\n            //turnKeys();\n            var isDown    = false,\n                mousedown = null,\n                mousemove = null;\n            canvas.addEventListener('mousedown', function (e) {\n                isDown = true;\n                mousedown = e;\n                mousemove = e;\n            }, false);\n            canvas.addEventListener('mousemove', function (e) {\n                if (isDown) {\n                    var movement_vector = new HexagonAlgebra.Axial(mousemove.offsetX - e.offsetX,\n                        mousemove.offsetY - e.offsetY);\n                    mousemove = e;\n                    board.handlers.scroll(canvas, movement_vector);\n                }\n            }, false);\n            canvas.addEventListener('mouseup', function (e) {\n                if (isDown) {\n                    isClick(board, mousedown, e);\n                    isDown = false;\n                }\n            }, false);\n            Board.drawMap(canvas, board.map);\n            self.send(response);\n        }\n    };\n};\n\nSidePanel.prototype = {\n    receive: function (msg) {\n        console.log(\"Module: \" + this.name + \" reached.\");\n        var action = msg.action;\n        switch (action) {\n            case \"joinGame\":\n                this.actions.joinGame(msg);\n                break;\n            default :\n                console.log(msg);\n                this.send(Messages.ping);\n        }\n    }\n\n};\nmodule.exports.sp = SidePanel;"]}